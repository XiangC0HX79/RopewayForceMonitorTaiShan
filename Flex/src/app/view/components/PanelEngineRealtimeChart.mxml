<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" 
		 xmlns:mx="library://ns.adobe.com/flex/mx" xmlns:components="app.view.components.*"
		 resize="dataCanvas_resizeHandler(event)">
	<fx:Declarations>
		<!-- 将非可视元素（例如服务、值对象）放在此处 -->
		<s:SolidColorStroke id="tickStroke" color="0xC2C2C2" weight="2"/>
		<s:SolidColorStroke id="gridStroke" color="gray" alpha="0.3" weight="1"/>
		<s:Sequence id="sequence"/>
		<s:Parallel id="parallel"/>
		<s:DateTimeFormatter id="dateFormatAve" dateTimePattern="MM.dd"/>
	</fx:Declarations>
	
	<fx:Script>
		<![CDATA[
			import flash.utils.setTimeout;
			
			import mx.binding.utils.BindingUtils;
			import mx.binding.utils.ChangeWatcher;
			import mx.collections.ArrayCollection;
			import mx.events.FlexEvent;
			import mx.events.ResizeEvent;
			
			import spark.effects.Move;
			
			import app.model.vo.EngineTempVO;
			import app.model.vo.EngineVO;
						
			[Bindable]private var _chartTitle:String;
						
			private var _watcher:ChangeWatcher;
			
			private var _engine:EngineVO;
			
			public function get engine():EngineVO
			{
				return _engine;
			}
			
			public function set engine(value:EngineVO):void
			{						
				_engine = value;
				
				_chartTitle = (value.pos == EngineVO.FIRST)?"温度1":"温度2";
								
				if(this.initialized)				
					RefreshChart(_engine.history,"date","temp","alarm");
				
				if(_watcher)
				{
					_watcher.unwatch();
				}
				
				_watcher = BindingUtils.bindSetter(tempSetter,value,"lastTemp");
			}
			
			private function tempSetter(obj:Object):void
			{	
				if(this.initialized)	
					ContinueChart(engine.history,"date","temp","alarm");				
			}
			
			private function calcuChartY(min:Number,max:Number):void
			{											
				var df:Number = max - min;
				var ave:Number = (max + min) / 2;
				
				if(df < 4 * 10)
				{
					var interval:Number = 10;
				}
				else if(df < 4 * 20)
				{
					interval = 20;
				}
				else if(df < 4 * 50)
				{
					interval = 50;
				}
				else if(df < 4 * 100)
				{
					interval = 100;
				}
				else
				{				
					min = Math.floor(min / 200) * 200;
					max = Math.ceil(max / 200) * 200;
					
					interval = (max - min) / 5;
				}
				
				min = Math.floor(ave / interval) * interval - 2 * interval;
				
				verticalAxis.interval = interval;
				verticalAxis.minimum = min;
				verticalAxis.maximum = min + 5 * interval;
			}
			
			private function calcuChartX(minDate:Date,maxDate:Date):void
			{							
				const ONE_MIN:Number = 60 * 1000;
				const TEN_MIN:Number = 10 * 60 * 1000;
				const HALF_HOUR:Number = 30 * 60 * 1000;
				const ONE_HOUR:Number = 60 * 60 * 1000;
				
				var min:Number = minDate.time;
				min = Math.floor(min / ONE_MIN) * ONE_MIN;
				
				var max:Number = maxDate.time;	
				max = Math.floor(max / ONE_MIN) * ONE_MIN + ONE_MIN;		
				
				var df:Number = max - min;
				
				if(df <= 10 * TEN_MIN)
				{					
					var labelUnits:String = "minutes";
					var interval:Number = Math.ceil(df / TEN_MIN);
					
					max = min + interval * TEN_MIN;
				}
				else if(df <= 10 * HALF_HOUR)
				{
					labelUnits = "minutes";
					interval = 30;
					
					min = Math.floor(min / HALF_HOUR) * HALF_HOUR;
					max = Math.ceil(max / HALF_HOUR) * HALF_HOUR;				
				}
				else
				{
					labelUnits = "hours";
					interval = 1;
					
					min = Math.floor(min / ONE_HOUR) * ONE_HOUR;
					max = Math.ceil(max / ONE_HOUR) * ONE_HOUR;
				}
				
				horizontalAxis.labelUnits = labelUnits;
				horizontalAxis.interval = interval;
				horizontalAxis.minimum = new Date(min);
				horizontalAxis.maximum = new Date(max);
			}
			
			private function drawYesterday():void
			{				
				if(engine.history.length == 0)
				{
					lineMax.visible = false;
					lineMin.visible = false;
					lineAve.visible = false;
					lbMax.visible = false;
					lbMin.visible = false;
					lbAve.visible = false;
					return;
				}
				
				//昨天数值
				lineMax.visible = true;
				lineMin.visible = true;
				lineAve.visible = true;
				lbMax.visible = true;
				lbMin.visible = true;
				lbAve.visible = true;
				
				var moves:Array = new Array;
				
				var pt:Point = dataCanvas.dataToLocal(0,engine.maxTemp);				
				var move:Move = new Move(lineMax);
				move.yTo = pt.y;
				moves.push(move);
				
				move = new Move(lbMax);
				move.yTo = pt.y - 30;
				moves.push(move);
				
				pt = dataCanvas.dataToLocal(0,engine.aveTemp);
				move = new Move(lineAve);
				move.yTo = pt.y;
				moves.push(move);
				
				move = new Move(lbAve);
				move.yTo = pt.y - 30;
				moves.push(move);
				
				pt = dataCanvas.dataToLocal(0,engine.minTemp);
				move = new Move(lineMin);
				move.yTo = pt.y;
				moves.push(move);
				
				move = new Move(lbMin);
				move.yTo = pt.y - 30;
				moves.push(move);
				
				parallel.end();
				parallel.children = moves;
				parallel.play();
				
				lbMax.text = "最高温度\n" + engine.maxTemp + " ℃";				
				lbAve.text = "平均温度\n" + engine.aveTemp + " ℃";				
				lbMin.text = "最低温度\n" + engine.minTemp + " ℃";
			}
			
			private function CalcuChartXY(minY:Number,maxY:Number,minDate:Date,maxDate:Date):void
			{			
				calcuChartY(minY,maxY);
				
				calcuChartX(minDate,maxDate);
				
				drawYesterday();
			}
						
			public function RefreshChart(dataProvider:ArrayCollection,xField:String,yField:String,alarmField:String):void
			{					
				for(var i:int = 0;i< groupPoint.numElements;i++)
				{
					var img:ChartImage = groupPoint.getElementAt(i) as ChartImage;
					img.removeEventListener(MouseEvent.MOUSE_OVER,onImageMouseOver);
					img.removeEventListener(MouseEvent.MOUSE_OUT,onImageMouseOut);
				}
				
				groupPoint.removeAllElements();
				groupLine.removeAllElements();
				
				if(dataProvider.length == 0)
				{
					return;
				}
				
				var array:Array = [];
				array = array.concat(dataProvider.source);
				array.sortOn(yField,Array.NUMERIC);
				
				CalcuChartXY(
					array[0][yField]
					,array[array.length - 1][yField]
					,dataProvider[0][xField]
					,dataProvider[dataProvider.length - 1][xField]
				);
											
				//添加折线\点								
				var animates:Array = [];								
				for(i = 0;i<dataProvider.length;i++)
				{
					var sData:* = dataProvider[i];
					
					img = new ChartImage;					
					img.addEventListener(MouseEvent.MOUSE_OVER,onImageMouseOver);		
					img.addEventListener(MouseEvent.MOUSE_OUT,onImageMouseOut);
					img.SetValue(dataCanvas,sData,sData[xField],sData[yField],sData[alarmField]);					
					groupPoint.addElement(img);		
					
					animates.push(img.scale);
					
					if(i < dataProvider.length - 1)
					{						
						var line:ChartLine = new ChartLine;
						
						var eData:* = dataProvider[i+1];
						line.SetValue(dataCanvas,sData[xField],sData[yField],eData[xField],eData[yField]);
						
						groupLine.addElement(line);
						
						animates.push(line.animate);
					}
				}
				
				sequence.end();
				sequence.children = animates;
				sequence.duration = 3000 / animates.length;
				sequence.play();				
			}		
			
			private function newChartImage(data:*,xValue:Date,yValue:Number,alarm:int):ChartImage
			{
				var img:ChartImage = new ChartImage;					
				img.addEventListener(MouseEvent.MOUSE_OVER,onImageMouseOver);		
				img.addEventListener(MouseEvent.MOUSE_OUT,onImageMouseOut);
				img.SetValue(dataCanvas,data,xValue,yValue,alarm);	
				
				groupPoint.addElement(img);		
				
				return img;
			}
			
			private function newChartLine(xValue1:Date,yValue1:Number,xValue2:Date,yValue2:Number):ChartLine
			{
				var line:ChartLine = new ChartLine;
				line.SetValue(dataCanvas,xValue1,yValue1,xValue2,yValue2);
				groupLine.addElement(line);			
				
				return line;
			}
			
			private function drawOldChart():Parallel
			{	
				var animates:Array = [];
				for(var i:Number = 0;i < groupPoint.numElements;i++)
				{
					var img:ChartImage = groupPoint.getElementAt(i) as ChartImage;	
					img.SetValue(dataCanvas);
					animates.push(img.mv);
					
					if(i < groupLine.numElements)
					{
						var line:ChartLine = groupLine.getElementAt(i) as ChartLine;
						line.SetValue(dataCanvas);
						animates.push(line.animate);
					}
				}	
				
				var parallel:Parallel = new Parallel;
				parallel.children = animates;
				
				return parallel;
			}
			
			public function ContinueChart(dataProvider:ArrayCollection,xField:String,yField:String,alarmField:String):void
			{		
				var sIndex:int = groupPoint.numElements;
				
				if((dataProvider.length == 0)
					||(dataProvider.length == sIndex))
					return;
								
				var array:Array = [];
				array = array.concat(dataProvider.source);
				array.sortOn(yField,Array.NUMERIC);
				
				CalcuChartXY(
					array[0][yField]
					,array[array.length - 1][yField]
					,dataProvider[0][xField]
					,dataProvider[dataProvider.length - 1][xField]
				);
				
				var animates:Array = [];		
				
				if(sIndex == 0)
				{
					animates.push(
						newChartImage(
							dataProvider[0]
							,dataProvider[0][xField]
							,dataProvider[0][yField]
							,dataProvider[0][alarmField]).scale
						);	
					
					sIndex ++;
				}				
				else
				{
					animates.push(drawOldChart());
				}
				
				for(var i:int = sIndex;i<dataProvider.length;i++)
				{						
					animates.push(
						newChartLine(
						dataProvider[i - 1][xField]
						,dataProvider[i - 1][yField]
						,dataProvider[i][xField]
						,dataProvider[i][yField]
						).animate
						);
					
					animates.push(
						newChartImage(
							dataProvider[i]
							,dataProvider[i][xField]
							,dataProvider[i][yField]
							,dataProvider[i][alarmField]).scale
					);	
				}
			
				sequence.end();
				sequence.children = animates;
				sequence.duration = (animates.length == 1)?1000:(3000/animates.length);
				sequence.play();
			}
			
			/*public function MoveChart():void
			{				
				var animates:Array = new Array;
				for(var i:Number = 0;i<groupPoint.numElements;i++)
				{
					var img:ChartImage = groupPoint.getElementAt(i) as ChartImage;						
					img.SetValue(dataCanvas);	
					animates.push(img.mv);
					
					if(i < groupLine.numElements)
					{
						var line:ChartLine = groupLine.getElementAt(i) as ChartLine;
						line.SetValue(dataCanvas);
						animates.push(line.animate);
					}
				}	
				
				sequence.end();
				
				var p:Parallel = new Parallel;
				p.children = animates;
				p.play();
			}*/
			
			private function onImageMouseOver(event:MouseEvent):void
			{
				var off:Number = 10;
				
				var img:ChartImage = event.currentTarget as ChartImage;		
				var et:EngineTempVO = img.data as EngineTempVO;		
				chartTip.data = et;
				
				var pt:Point = dataCanvas.dataToLocal(et.date,et.temp);
				var prect:Rectangle = new Rectangle(0,0,groupLabel.width,groupLabel.height);
				
				chartTip.validateNow();
				
				var w:Number = chartTip.measuredWidth;
				var h:Number = chartTip.measuredHeight;
				
				var lbrect:Rectangle = new Rectangle(pt.x - off - w,pt.y + off,w,h);
				var rbrect:Rectangle = new Rectangle(pt.x + off,pt.y + off,w,h);
				var ltrect:Rectangle = new Rectangle(pt.x - off - w,pt.y - off - h,w,h);
				var rtrect:Rectangle = new Rectangle(pt.x + off,pt.y - off - h,w,h);
				
				if(prect.containsRect(lbrect))
				{
					chartTip.x = lbrect.x;
					chartTip.y = lbrect.y;
				}
				else if(prect.containsRect(rbrect))
				{
					chartTip.x = rbrect.x;
					chartTip.y = rbrect.y;
				}
				else if(prect.containsRect(ltrect))
				{
					chartTip.x = ltrect.x;
					chartTip.y = ltrect.y;
				}
				else
				{
					chartTip.x = rtrect.x;
					chartTip.y = rtrect.y;
				}
				
				chartTip.visible = true;
			}
			
			private function onImageMouseOut(event:MouseEvent):void
			{
				chartTip.visible = false;
			}
			
			
			private var _resizeExecuting:Boolean = false;
			
			protected function dataCanvas_resizeHandler(event:ResizeEvent):void
			{				
				_resizeExecuting = true;
				
				flash.utils.setTimeout(onResize,200);
			}
			
			private function onResize():void
			{
				if(_resizeExecuting)
				{
					if(engine && engine.history && (engine.history.length > 0))
					{
						RefreshChart(engine.history,"date","temp","alarm");		
					}
				}
				
				_resizeExecuting = false;
			}	
			
			protected function dataCanvas_updateCompleteHandler(event:FlexEvent):void
			{
				var pt:Point = this.globalToContent(dataCanvas.contentToGlobal(new Point(0,0)));
				
				groupChart.x = pt.x;
				groupChart.y = pt.y;
				groupChart.width = dataCanvas.width;
				groupChart.height = dataCanvas.height;
				
				labelChart.x = pt.x;
				labelChart.y = pt.y;
				labelChart.width = dataCanvas.width;
				labelChart.height = dataCanvas.height;
			}
		]]>
	</fx:Script>
	
	<s:Rect id="border" left="0" right="0" top="0" bottom="0">
		<s:stroke>
			<s:SolidColorStroke weight="1" color="#63c3d6"/>
		</s:stroke>
	</s:Rect>	
	
	<s:Group id="labelChart">
		<s:Rect id="lineMax" height="1" left="10" right="10" visible="false">
			<s:fill>
				<s:BitmapFill source="@Embed('assets/image/yes_stroke.png')" fillMode="repeat"/>
			</s:fill>
		</s:Rect>
		<s:Rect id="lineAve" height="1" left="10" right="10" visible="false">
			<s:fill>
				<s:BitmapFill source="@Embed('assets/image/yes_stroke.png')" fillMode="repeat"/>
			</s:fill>
		</s:Rect>
		<s:Rect id="lineMin" height="1" left="10" right="10" visible="false">
			<s:fill>
				<s:BitmapFill source="@Embed('assets/image/yes_stroke.png')" fillMode="repeat"/>
			</s:fill>
		</s:Rect>
		
		<s:Label right="15" id="lbMax" textAlign="center"
				 verticalAlign="middle"/> 	
		<s:Label right="15" id="lbMin" textAlign="center"
				 verticalAlign="middle"/> 	
		<s:Label right="15" id="lbAve" textAlign="center"
				 verticalAlign="middle"/> 
	</s:Group>
	
	<mx:LineChart id="lineChart" left="20" right="40" bottom="20" top="40">
		<mx:backgroundElements>
			<fx:Array>						
				<mx:GridLines gridDirection="both" 
							  horizontalStroke="{gridStroke}"
							  verticalStroke="{gridStroke}"/>
			</fx:Array>
		</mx:backgroundElements>
		
		<mx:annotationElements>
			<mx:CartesianDataCanvas id="dataCanvas" updateComplete="dataCanvas_updateCompleteHandler(event)"/>
		</mx:annotationElements>
		
		<mx:verticalAxis>
			<mx:LinearAxis id="verticalAxis"/>
		</mx:verticalAxis>
		<mx:horizontalAxis>
			<mx:DateTimeAxis displayLocalTime="true" 
							 alignLabelsToUnits="true"
							 id="horizontalAxis"/>
		</mx:horizontalAxis>
		
		<mx:verticalAxisRenderers>					
			<mx:AxisRenderer axis="{verticalAxis}" 
							 axisStroke="{tickStroke}" tickStroke="{tickStroke}" 
							 minorTickPlacement="none"/>
		</mx:verticalAxisRenderers>
		
		<mx:horizontalAxisRenderers>			
			<mx:AxisRenderer axis="{horizontalAxis}" 
							 axisStroke="{tickStroke}" tickStroke="{tickStroke}" 
							 minorTickPlacement="none"/>					
		</mx:horizontalAxisRenderers>
		
		<mx:series>
			<mx:LineSeries yField="temp" xField="date"/>
		</mx:series>
	</mx:LineChart>		
	
	<s:Group id="groupChart">		
		<s:Group id="groupLine" width="100%" height="100%"/>
		<s:Group id="groupPoint" width="100%" height="100%">
			<s:filters>
				<s:DropShadowFilter 
					distance="2" 
					angle="45" 
					color="0x0" 
					alpha="1" 
					blurX="4" 
					blurY="4" 
					strength="1" 
					quality="1" 
					hideObject="false"
					inner="false" 
					knockout="false"/>
			</s:filters>
		</s:Group>
		
		<s:Group id="groupLabel" width="100%" height="100%">
			<components:ChartTipEngine id="chartTip" visible="false"/>
		</s:Group>
	</s:Group>
	
	<s:Label left="10" top="20" text="温度（℃）"/>
	<s:Label right="15" bottom="40" text="时间"/>
	<s:Label y="10" fontSize="24" fontWeight="bold" horizontalCenter="0" color="0x1b5aa2"
			 text="{_chartTitle} - 实时监测曲线"/>
</s:Group>
